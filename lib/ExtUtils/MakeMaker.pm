package ExtUtils::MakeMaker;

# Authors:
#	Andy Dougherty	<doughera@lafcol.lafayette.edu>
#   Andreas Koenig	<k@franz.ww.TU-Berlin.DE>
#   Tim Bunce		<Tim.Bunce@ig.co.uk>

# Last Revision: 31 Oct 1994

# This utility is designed to write a Makefile for an extension 
# module from a Makefile.PL. It is based on the excellent Makefile.SH
# model provided by Andy Dougherty and the perl5-porters. 

# It splits the task of generating the Makefile into several
# subroutines that can be individually overridden.
# Each subroutine returns the text it wishes to have written to
# the Makefile.

use Config;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(writeMakefile mkbootstrap $Verbose);
@EXPORT_OK = qw(%att %recognized_att_keys);

use strict qw(refs);

# Setup dummy package:
# MY exists for overriding methods to be defined within
unshift(@MY::ISA, qw(MM));

$Verbose = 0;
$^W=1;


# For most extensions it will do to call
#
#   use ExtUtils::MakeMaker
#   &writeMakefile("LIBS" => ["-L/usr/alpha -lfoo -lbar"]);
#
# from Makefile.PL in the extension directory
# It is also handy to include some of the following attributes:
#
$attrib_help = q{
 NAME:		Perl module name for this extension (DBD::Oracle)
 DISTNAME:	Your name for distributing the package (by tar file)
 VERSION:	Your version number for distributing the package

 INST_LIB:	Directory containing the Perl library,
		used to both build from and install into.
 PERL_SRC:	Directory containing the Perl source code.
		(use of this should be avoided)

 INC:		Include file dirs eg: '-I/usr/5include -I/path/to/inc'
 DEFINE:	something like "-DHAVE_UNISTD_H"
 OBJECT:	List of object files, defaults to '$(BASEEXT).o',
		but can be a long string containing            
		all object files, e.g. "tkpBind.o tkpButton.o tkpCanvas.o"
 LIBS:		An anonymous array of libraries to be searched for
		until we get at least some output from ext/util/extliblist
		    'LIBS' => [ "-lgdbm", "-ldbm -lfoo", "-ldbm.nfs" ]
 LDTARGET:	defaults to "$(OBJECT)" and is used in the ld command
		(some machines need additional switches for bigger projects)
 ARMAYBE:	Defaults to ":", but can be used to run ar before ld

 AUTOSPLITMAXLEN:	Alters AutoSplit warning threshold for name clashes
 LINKTYPE:	=>'static' or 'dynamic' (default unless usedl=undef in config.sh)
 CONFIG:	=>[qw(archname manext)] defines ARCHNAME & MANEXT from config.sh

 MINIPERL:
 FULLPERL:

Additional lowercase attributes can be used to pass parameters to the
methods which implement that part of the Makefile:

 dynamic:	{OTHERLDFLAGS => ""}
 clean:		{FILES => "*.xyz foo"}
 realclean:	{FILES => "$(AUTOEXT)/*.xyz"}
 distclean:	{TARNAME=>'MyTarName', TARFLAGS=>'cvfF', COMPRESS=>'gzip'}
};

%recognized_att_keys = ();
foreach(split(/\n/,$attrib_help)){
    chomp;
    next unless m/^\s*(\w+):\s*(.*)/;
    $recognized_att_keys{$1} = $2;
    print "Attribute '$1' => '$2'\n" if ($Verbose >= 2);
}


# Be aware, that you can also pass attributes into the %att hash table
# by calling Makefile.PL with arguments of the form INST_LIB=/some/where.

# If the Makefile generated by default does not fit your purpose,
# and you cannot change it via writeMakefile parameters then
# you may specify private subroutines in the Makefile.PL as there are:
#
# MY->initialize        =>   sub MY::initialize{ ... }
# MY->post_initialize   =>   sub MY::post_initialize{ ... }
# MY->constants         =>   etc
# MY->dynamic
# etc. (see function writeMakefile, for the current breakpoints)
#
# Each subroutines returns the text it wishes to have written to
# the Makefile. To override a section of the Makefile you can
# either say:
#	sub MY::co { "new literal text" }
# or you can edit the default by saying something like:
#	sub MY::co { $_=MM->co; s/old text/new text/; $_ }
#
# `make distclean'  builds $(DISTNAME)-$(VERSION).tar.Z after a clean
#
# If you still need a different solution, try to develop another 
# subroutine, that fits your needs and submit the diffs to 
# perl5-porters@isu.edu or comp.lang.perl as appropriate.



sub writeMakefile {
    %att = @_;
    local($\)="\n";

    print STDOUT "MakeMaker" if $Verbose;

    parse_args(\%att, @ARGV);
    my(%initial_att) = %att; # record initial attributes

    MY->initialize(@ARGV);

    print STDOUT "Writing Makefile for $att{NAME} (with variable substitutions)";

    open MAKE, ">Makefile" or die "Unable to open Makefile: $!";

    print MAKE "# This Makefile is for the $att{NAME} extension to perl.\n#";
    print MAKE "# It was written by Makefile.PL, so don't edit it, edit";
    print MAKE "# Makefile.PL instead. ANY CHANGES MADE HERE WILL BE LOST!\n#";
    print MAKE "#	MakeMaker Parameters: ";
    foreach(sort keys %initial_att){
	print MAKE "#		$_ = '$att{$_}'";
    }

    foreach( qw(
	    post_initialize
	    constants post_constants
	    dynamic static
	    co c installpm subdirs
	    clean realclean distclean test install
	    force perldepend postamble)){
	print MAKE MY->$_( %{$att{$_} || {}} );
    }

    close MAKE;

    chmod 0644, "Makefile";
    system("$Config{'eunicefix'} Makefile") unless $Config{'eunicefix'} eq ":";

    1;
}


sub mkbootstrap{
    parse_args(\%att, @ARGV);
    MY->mkbootstrap(@_)
}


sub parse_args{
    my($attr, @args) = @_;
    foreach (@args){
	next unless m/(.*)=(.*)/;
	$$attr{$1} = $2;
    }
    # catch old-style and inform user how to 'upgrade'
    if (defined $$attr{'potential_libs'}){
	my($msg)="'potential_libs' => '$$attr{potential_libs}' should be";
	if ($$attr{'potential_libs'}){
	    print STDERR "$msg changed to 'LIBS' => ['$$attr{potential_libs}']\n";
	} else {
	    print STDERR "$msg deleted.\n";
	}
	$$attr{LIBS} = [$$attr{'potential_libs'}];
	delete $$attr{'potential_libs'};
    }
    foreach(sort keys %{$attr}){
	print STDOUT "	$_ = '$$attr{$_}'" if ($Verbose);
	warn "'$_' is not a known MakeMaker parameter name.\n"
	    unless exists $recognized_att_keys{$_};
    }
}




# --- Define the MakeMaker default methods ---

package MM;

use Config;
require Exporter;

Exporter::import('ExtUtils::MakeMaker', qw(%att %recognized_att_keys $Verbose));

# These attributes cannot be overridden externally
@other_att_keys=qw(EXTRALIBS BSLOADLIBS LDLOADLIBS);


sub find_perl{
    my($self, $ver, $names, $dirs, $trace) = @_;
    my($name, $dir);
    print "Looking for perl $ver by these names: @$names, in these dirs: @$dirs\n"
	if ($trace);
    foreach $dir (@$dirs){
	foreach $name (@$names){
	    print "checking $dir/$name\n" if ($trace >= 2);
	    next unless -x "$dir/$name";
	    print "executing $dir/$name\n" if ($trace);
	    my($out) = `$dir/$name -e 'require $ver; print "VER_OK\n" ' 2>&1`;
	    return "$dir/$name" if $out =~ /VER_OK/;
	}
    }
    warn "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
    0; # false and not empty
}


sub initialize {
    # Find out directory name.  This may also be the extension name.
    chop($pwd=`pwd`);

    unless ($att{PERL_SRC}){
	foreach(qw(../.. ../../.. ../../../..)){
	    ($att{PERL_SRC}=$_, last) if -f "$_/config.sh";
	}
    }
    die "Unable to locate perl source. Try setting PERL_SRC\n"
	unless ($att{PERL_SRC});
    chdir $att{PERL_SRC} or die "Couldn't chdir $att{PERL_SRC}: $!";
    chop($att{PERL_SRC_ABS}=`pwd`);
    chdir $pwd;

    $att{CONFIG_SH} = "$att{PERL_SRC}/config.sh";
    die "Can't find config.sh" unless (-f $att{CONFIG_SH});

    $att{INST_LIB} = "$att{PERL_SRC}/lib" unless ($att{INST_LIB});
    die "INST_LIB ($att{INST_LIB}) is not a perl library directory"
	unless (-f "$att{INST_LIB}/Exporter.pm");

    # NAME    = The perl module name for this extension (eg DBD::Oracle).
    # FULLEXT = Pathname for extension directory (eg DBD/Oracle).
    # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT.
    # ROOTEXT = Directory part of FULLEXT. May be empty.
    unless($att{NAME}){ # we have to guess our name
	my($name) = $pwd;
	$name =~ s:.*/:: unless ($name =~ s:^.*/ext/::);
	($att{NAME} =$name) =~ s#/#::#g;
    }
    ($att{FULLEXT} =$att{NAME}) =~ s#::#/#g ;		#eg. BSD/Foo/Socket
    ($att{BASEEXT} =$att{NAME}) =~ s#.*::##;		#eg. Socket
    ($att{ROOTEXT} =$att{NAME}) =~ s#(::)?\Q$att{BASEEXT}\E$## ; # eg. BSD/Foo

    # Find Perl 5. The only contract here is that both 'MINIPERL' and 'FULLPERL'
    # will be working versions of perl 5.
    $att{'MINIPERL'} = MY->find_perl(5.0, [ qw(perl5 perl miniperl) ],
			    [ $att{PERL_SRC}, split(":", $ENV{PATH}) ], 0 )
	    unless ($att{'MINIPERL'} && -x $att{'MINIPERL'});

    # Define 'FULLPERL' to be a non-miniperl (used in test: target)
    ($att{'FULLPERL'} = $att{'MINIPERL'}) =~ s/miniperl/perl/
	unless ($att{'FULLPERL'} && -x $att{'FULLPERL'});

    for $key (keys(%recognized_att_keys), @other_att_keys){
	# avoid warnings for uninitialized vars
	$att{$key} = "" unless exists $att{$key};
    }

    # compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $att{'LIBS'}
    foreach ( @{$att{'LIBS'} || []} ){
	my(@libs);
	if (@libs = MY->extliblist($_)){
	    @att{EXTRALIBS, BSLOADLIBS, LDLOADLIBS} = @libs;
	    last;
	}
    }

    warn "CONFIG must be an array ref\n"
	if ($att{CONFIG} and ref $att{CONFIG} ne 'ARRAY');
    $att{CONFIG} = [] unless (ref $att{CONFIG});
    push(@{$att{CONFIG}}, qw(
	    cc libc ldflags lddlflags ccdlflags cccdlflags
	    ranlib so dlext dlsrc
	    installprivlib installarchlib
	));
    push(@{$att{CONFIG}}, 'shellflags') if $Config{'shellflags'};
}


sub extliblist{
    my($self, $libs) = @_;
    my(@old) = MY->old_extliblist($libs);
    my(@new) = MY->new_extliblist($libs);
    # add cross checking and warning here
    @old;
}


sub old_extliblist {
    my($self, $potential_libs)=@_;
    return () unless $potential_libs;
    print STDERR "Potential libraries are '$potential_libs':" if $Verbose;
    # Now run ext/util/extliblist to discover what *libs definitions
    # are required for the needs of $potential_libs
    $ENV{'potential_libs'} = $potential_libs;
    $_=`. $att{CONFIG_SH}
	. $att{PERL_SRC}/ext/util/extliblist;
	echo EXTRALIBS=\$extralibs
	echo BSLOADLIBS=\$dynaloadlibs
	echo LDLOADLIBS=\$statloadlibs
	`;
    my(@w);
warn "old_extliblist should just return info an not set %att locally\n";
    foreach $line (split "\n", $_){
	chomp $line;
	if ($line =~ /(.*)\s*=\s*(.*)\s*$/){
	    $att{$1} = $2;
	    print STDERR "	$1 = $2" if $Verbose;
	}else{
	    push(@w, $line);
	}
    }
    print STDERR "Messages from extliblist:\n", join("\n",@w,'')
       if @w ;
    @att{qw(EXTRALIBS BSLOADLIBS LDLOADLIBS)};
}


sub new_extliblist {
    my($self, $potential_libs)=@_;
    return () unless $potential_libs;
    print STDERR "Potential libraries are '$potential_libs':" if $Verbose;

    $so   = $Config{'so'};
    $libs = $Config{'libs'};

    # compute $extralibs, $dynaloadlibs and $statloadlibs from
    # $potential_libs
    # this is a rewrite of Andy Dougherty's extliblist in perl
    # its home is in <distribution>/ext/util

    my(@LIBPATH) = split " ", $Config{'libpth'};
    my(@ldloadlibs);
    my(@bsloadlibs);
    my(@extralibs);

    foreach $thislib (split ' ', $potential_libs){

	# Handle possible linker path arguments.
	if ($thislib =~ s/^-L//){
	    unless (-d $thislib){
		warn "-L$thislib ignored, directory does not exist\n"
			if $Verbose;
		next;
	    }
	    push(@LIBPATH, $thislib);
	    push(@extralibs,  "-L$thislib");
	    push(@ldloadlibs, "-L$thislib");
	    next;
	}

	# Handle possible library arguments.
	$thislib =~ s/^-l//;
	foreach $thispth (@LIBPATH){

	    if (@fullname=<${thispth}/lib${thislib}.${so}.[0-9]*>){
		$fullname=$fullname[-1]; #ATTN: 10 looses against 9!
	    } elsif (-f ($fullname="$thispth/lib$thislib.$so")){
	    } elsif (-f ($fullname="$thispth/lib${thislib}_s.a")){
	    } elsif (-f ($fullname="$thispth/lib$thislib.a")){
	    } elsif (-f ($fullname="$thispth/Slib$thislib.a")){
	    } else { 
		warn "$thislib not found in $thispth\n" if $Verbose;
		next;
	    }
	    warn "'-l$thislib' found at $fullname\n" if $Verbose;

	    # Now update library lists

	    # what do we know about this library...
	    my $is_dyna = ($fullname !~ /\.a$/);
	    my $in_perl = ($libs =~ /\b-l${thislib}\b|\b-l${thislib}_s\b/);

	    # Do not add it into the list if it is already linked in
	    # with the main perl executable.
	    push(@extralibs, "-l$thislib") unless $in_perl;

	    # We might be able to load this archive file dynamically
	    if ( $Config{'dlsrc'} =~ /dl_next|dl_dld/){
		push(@bsloadlibs, "-l$thislib"); # " $fullname";
	    } else {
		if ($is_dyna){
                    # For SunOS4, do not add in this shared library if
                    # it is already linked in the main perl executable
		    push(@ldloadlibs, "-l$thislib")
			unless ($in_perl and $Config{'osname'} eq 'sunos');
		} else {
		    push(@ldloadlibs, "-l$thislib");
		}
	    }
	}
    }
# need to join arrays into strings and decide if we have any worthwhile results
warn "return something here...";
}




sub post_initialize{
    "";
}
 

sub constants {
    my(@m);

    $att{BOOTDEP}  = (-f "$att{BASEEXT}_BS") ? "$att{BASEEXT}_BS" : "";
    $att{OBJECT}   = '$(BASEEXT).o' unless $att{OBJECT};
    $att{LDTARGET} = '$(OBJECT)'    unless $att{LDTARGET};
    $att{ARMAYBE}  = ":"            unless $att{ARMAYBE};
    $att{AUTOSPLITMAXLEN} = 8       unless $att{AUTOSPLITMAXLEN};
    $att{LINKTYPE} = ($Config{'usedl'}) ? 'dynamic' : 'static'
	unless $att{LINKTYPE};


    push @m, "
DISTNAME = $att{DISTNAME}
VERSION = $att{VERSION}

# Where should we install this extension
INST_LIB = $att{INST_LIB}

# Where is the perl source code located (eventually we should
# be able to build extensions without requiring the perl source
# but that's a long way off yet).
PERL_SRC = $att{PERL_SRC}

# deprecated in favour of INST_LIB and PERL_SRC above:
TOP = \$(PERL_SRC)

INC = $att{INC}
DEFINE = $att{DEFINE}
OBJECT = $att{OBJECT}
LDTARGET = $att{LDTARGET}

PERL = $att{'MINIPERL'}
FULLPERL = $att{'FULLPERL'}

LINKTYPE = $att{LINKTYPE}
ARMAYBE = $att{ARMAYBE}
";

    push @m, "# These definitions are exact copies of config.sh\n";
    my(%once_only);
    foreach(@{$att{'CONFIG'}}){
	next if $once_only{$_};
	warn "CONFIG key '$_' does not exist in Config.pm\n"
		unless exists $Config{$_};
	push @m, "\U$_\E = $Config{$_}\n";
	$once_only{$_} = 1;
    }

    push @m, "
# $att{NAME} might depend on some other libraries.
#
# Dependant libraries are linked in either by the ld command
# at build time or by the DynaLoader at bootstrap time.
# Which method is used depends in the platform and the types
# of libraries available (shared or non-shared).
#
# These comments may need revising:
#
# EXTRALIBS =	Full list of libraries needed for static linking.
#		Only those libraries that actually exist are included.
#
# BSLOADLIBS =	List of those libraries that are needed but can be
#		linked in dynamically on this platform.  On SunOS, for
#		example, this would be .so* libraries, but not archive
#		libraries.  The bootstrap file is installed only if
#		this list is not empty.
#
# LDLOADLIBS =	List of those libraries which must be statically
#		linked into the shared library.  On SunOS 4.1.3, 
#		for example,  I have only an archive version of -lm,
#		and it must be linked in statically.
#
EXTRALIBS  = $att{'EXTRALIBS'}
BSLOADLIBS = $att{'BSLOADLIBS'}
LDLOADLIBS = $att{'LDLOADLIBS'}

";

    push @m, "
# NAME = The perl module name for this extension.
#(EXTMODNAME = old name for NAME included for compatibility)
# FULLEXT = Pathname for extension directory (eg DBD/Oracle).
# BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT.
# ROOTEXT = Directory part of FULLEXT. May be empty.
NAME = $att{NAME}
EXTMODNAME = $att{NAME}
FULLEXT = $att{FULLEXT}
BASEEXT = $att{BASEEXT}
ROOTEXT = $att{ROOTEXT}
# and for backward compatibility and for AIX support (due to change!)
EXT = $att{BASEEXT}

# $att{NAME} might have its own bootstrap support
BOOTSTRAP = $att{BASEEXT}.bs
BOOTDEP = $att{BOOTDEP}
";

    push @m, '
# Where to put things:
AUTO = $(INST_LIB)/auto
AUTOEXT = $(INST_LIB)/auto/$(FULLEXT)
INST_BOOT = $(AUTOEXT)/$(BASEEXT).bs
INST_DYNAMIC = $(AUTOEXT)/$(BASEEXT).$(DLEXT)
INST_STATIC = $(BASEEXT).a
INST_PM = $(INST_LIB)/$(FULLEXT).pm
';

    push @m, q{
# Tools
SHELL = /bin/sh
XSUBPP = $(PERL_SRC)/ext/xsubpp
CCCMD = `sh $(shellflags) $(PERL_SRC)/cflags -c }.$att{CONFIG_SH}.q{ $@`
# the following is a portable way to say mkdir -p
MKPATH = $(PERL) -we '$$"="/"; foreach(split(/\//,$$ARGV[0])){ push(@p, $$_); next if -d "@p"; print "mkdir @p\n"; mkdir("@p",0777)||die "mkdir @p: $$!" } exit 0;'
AUTOSPLITLIB = $(PERL) -I$(INST_LIB) -e 'use AutoSplit; chdir("$(INST_LIB)/..") or die $$!; $$AutoSplit::Maxlen=}.$att{AUTOSPLITMAXLEN}.q{; autosplit_lib_modules(@ARGV) ;'
};

    push @m, '

all ::	$(LINKTYPE)

config :: Makefile
	@$(MKPATH) $(AUTOEXT)

install ::

';

    join('',@m);
}


sub post_constants{
    "";
}


sub co {
    '
.c.o:
	$(CCCMD) $(CCCDLFLAGS) $(DEFINE) -I$(PERL_SRC) $(INC) $*.c
';
}


sub dynamic {
    my(%attribs) = @_;
    my($otherldflags) = $attribs{OTHERLDLFLAGS} || "";
    '
# Target for Dynamic Loading:
dynamic::	$(INST_DYNAMIC) $(INST_PM) $(INST_BOOT)

$(INST_DYNAMIC): $(OBJECT)
	@$(MKPATH) $(AUTOEXT)
	$(ARMAYBE) cr $(BASEEXT).a $(OBJECT) 
	ld $(LDDLFLAGS) -o $@ $(LDTARGET) '.$otherldflags.' $(LDLOADLIBS)

$(BOOTSTRAP): $(BOOTDEP)
	$(PERL) -I$(INST_LIB) -e \'use ExtUtils::MakeMaker; &mkbootstrap("$(BSLOADLIBS)");\' INST_LIB=$(INST_LIB) PERL_SRC=$(PERL_SRC)
	touch $(BOOTSTRAP)

$(INST_BOOT): $(BOOTSTRAP)
	@test ! -s $(BOOTSTRAP) || cp $(BOOTSTRAP) $@
';
}


sub static {
    '
# Target for Static Loading:
static:: $(INST_STATIC) $(INST_PM)

$(INST_STATIC): $(OBJECT)
	ar cr $@ $(OBJECT)
	$(RANLIB) $@
	echo $(EXTRALIBS) >> $(PERL_SRC)/ext.libs
';
}


sub c {
    my(@tmdeps) = ('$(PERL_SRC)/ext/typemap');
    push(@tmdeps, "typemap") if -f "typemap";
    my(@tmargs) = map("-typemap $_", @tmdeps);
    '
$(BASEEXT).c:	$(BASEEXT).xs $(XSUBPP) '."@tmdeps".' $(PERL_SRC)/cflags
	$(PERL) $(XSUBPP) '."@tmargs".' $(BASEEXT).xs >tmp
	mv tmp $@
';
}


sub installpm {
    '
$(INST_PM):	$(BASEEXT).pm
	@$(MKPATH) $(INST_LIB)/$(ROOTEXT)
	rm -f $@
	cp $(BASEEXT).pm $@
	$(AUTOSPLITLIB) $(NAME)
';
}


sub subdirs {
    my(@m);
    # This method provides a mechanism to automatically deal with
    # subdirectories containing further Makefile.PL scripts.
    # It calls the subdir_x() method for each subdirectory.
    foreach(<*/Makefile.PL>){
	s:/Makefile\.PL$:: ;
	push @m, MY->subdir_x($_);
    }
    join('',@m);
}

sub subdir_x {
    my($self, $subdir) = @_;
    my(@m);
    # The intention is that the calling Makefile.PL should define the
    # $(SUBDIR_MAKEFILE_PL_ARGS) make macro to contain whatever
    # information needs to be passed down to the other Makefile.PL scripts.
    # If this does not suit your needs you'll need to write your own
    # MY::subdir_x() method to override this one.
    qq{
config :: $subdir/Makefile

$subdir/Makefile: $subdir/Makefile.PL
	\$(PERL) -I\$(INST_LIB) -e 'chdir("$subdir") and do "Makefile.PL"' \$(SUBDIR_MAKEFILE_PL_ARGS); \\

all ::
	cd $subdir ; \$(MAKE) config
	cd $subdir ; \$(MAKE) all
};
}


sub clean {
    my(%attribs) = @_;
    my($files) = $attribs{FILES} || "";
    '
# Delete temporary files but do not touch installed files
clean::
	rm -f *.o *.a mon.out core $(BASEEXT).c so_locations
	rm -f makefile Makefile $(BOOTSTRAP) $(BASEEXT).bso '.$files.'
';
}

sub realclean {
    my(%attribs) = @_;
    my($files) = $attribs{FILES} || "";
    '
# Delete temporary files (via clean) and also delete installed files
realclean purge::  clean
	rm -f $(INST_DYNAMIC) $(INST_STATIC) $(INST_BOOT)
	rm -rf $(INST_PM) $(AUTOEXT) '.$files.'
';
}


sub test {
    my(%attribs) = @_;
    my($tests) = $attribs{TESTS} || "t/*.t";
    "
test: all
	\$(FULLPERL) -I\$(INST_LIB) -e 'use Test::Harness; runtests \@ARGV;' $tests
";
}


sub install {
    '
# used if installperl will not be installing it for you
install:: all
	# Not defined. Makefile, by default, builds the extension directly
	# into $(INST_LIB) so "installing" does not make much sense.
	# If INST_LIB is in the perl source tree then installperl will
	# install the extension when it installs perl.
';
}


sub distclean {
    my(%attribs) = @_;
    my($tarname)  = $attribs{TARNAME}  || '$(DISTNAME)-$(VERSION)';
    my($tarflags) = $attribs{TARFLAGS} || 'cvf';
    my($compress) = $attribs{COMPRESS} || 'compress';
    "
distclean:     clean
	rm -f Makefile *~ t/*~
	cd ..; tar $tarflags $tarname.tar \$(BASEEXT)
	cd ..; $compress $tarname.tar
";
}


sub force {
    '
# Phony target to force checking subdirectories.
FORCE:
';
}


sub perldepend {
    '
$(OBJECT) : Makefile
$(OBJECT) : $(PERL_SRC)/EXTERN.h
$(OBJECT) : $(PERL_SRC)/INTERN.h
$(OBJECT) : $(PERL_SRC)/XSUB.h
$(OBJECT) : $(PERL_SRC)/av.h
$(OBJECT) : $(PERL_SRC)/cop.h
$(OBJECT) : $(PERL_SRC)/cv.h
$(OBJECT) : $(PERL_SRC)/dosish.h
$(OBJECT) : $(PERL_SRC)/embed.h
$(OBJECT) : $(PERL_SRC)/form.h
$(OBJECT) : $(PERL_SRC)/gv.h
$(OBJECT) : $(PERL_SRC)/handy.h
$(OBJECT) : $(PERL_SRC)/hv.h
$(OBJECT) : $(PERL_SRC)/keywords.h
$(OBJECT) : $(PERL_SRC)/mg.h
$(OBJECT) : $(PERL_SRC)/op.h
$(OBJECT) : $(PERL_SRC)/opcode.h
$(OBJECT) : $(PERL_SRC)/patchlevel.h
$(OBJECT) : $(PERL_SRC)/perl.h
$(OBJECT) : $(PERL_SRC)/perly.h
$(OBJECT) : $(PERL_SRC)/pp.h
$(OBJECT) : $(PERL_SRC)/proto.h
$(OBJECT) : $(PERL_SRC)/regcomp.h
$(OBJECT) : $(PERL_SRC)/regexp.h
$(OBJECT) : $(PERL_SRC)/scope.h
$(OBJECT) : $(PERL_SRC)/sv.h
$(OBJECT) : $(PERL_SRC)/unixish.h
$(OBJECT) : $(PERL_SRC)/util.h
$(PERL_SRC)/config.h: $(PERL_SRC)/config.sh; cd $(PERL_SRC); /bin/sh config_h.SH
$(PERL_SRC)/embed.h:  $(PERL_SRC)/config.sh; cd $(PERL_SRC); /bin/sh embed_h.SH
$(PERL_SRC)/cflags:   $(PERL_SRC)/config.sh; cd $(PERL_SRC); /bin/sh cflags.SH

Makefile:	Makefile.PL
	$(PERL) -I$(INST_LIB) Makefile.PL
';
}


sub postamble{
    "";
}




sub mkbootstrap {
#
# mkbootstrap, by:
#
#	Andreas Koenig <k@otto.ww.TU-Berlin.DE>
#	Tim Bunce <Tim.Bunce@ig.co.uk>
#	Andy Dougherty <doughera@lafcol.lafayette.edu>
#
#  This perl script attempts to make a bootstrap file for use by this
#  system's DynaLoader. It typically gets called from an extension
#  Makefile.
#
# There is no .bs file supplied with the extension. Instead a _BS
# file which has code for the special cases, like posix for berkeley db
# on the NeXT.
# 
# This file will get parsed, and produce a maybe empty
# @DynaLoader::dl_resolve_using array for the current architecture.
# That will be extended by $BSLOADLIBS, which was computed by Andy's
# extliblist script. If this array still is empty, we do nothing, else
# we write a .bs file with an @DynaLoader::dl_resolve_using array, but
# without any `if's, because there is no longer a need to deal with
# special cases.
# 
# The _BS file can put some code into the generated .bs file by placing
# it in $bscode. This is a handy 'escape' mechanism that may prove
# useful in complex situations.
# 
# If @DynaLoader::dl_resolve_using contains -L* or -l* entries then
# mkbootstrap will automatically add a dl_findfile() call to the
# generated .bs file.
#
    my($self, @dynaloadlibs)=@_;
    print STDERR "	dynaloadlibs=@dynaloadlibs" if $Verbose;
    require DynaLoader; # we need DynaLoader, if the *_BS gets interpreted
    import DynaLoader;  # we don't say `use', so if DynaLoader is not 
	          # yet built MakeMaker works nonetheless except here

    initialize(@ARGV) unless defined $att{'PERL'};

    rename "$att{BASEEXT}.bs", "$att{BASEEXT}.bso";

    if (-f "$att{BASEEXT}_BS"){
	$_ = "$att{BASEEXT}_BS";
	package DynaLoader; # execute code as if in DynaLoader
	local($osname, $dlsrc) = (); # avoid warnings
	($osname, $dlsrc) = @Config::Config{qw(osname dlsrc)};
	$bscode = "";
	unshift @INC, ".";
	require $_;
    }

    if ($Config{'dlsrc'} =~ /^dl_dld/){
	package DynaLoader;
	push(@dl_resolve_using, dl_findfile('-lc'));
    }

    my(@all) = (@dynaloadlibs, @DynaLoader::dl_resolve_using);
    my($method) = '';
    if (@all){
	open BS, ">$att{BASEEXT}.bs"
		or die "Unable to open $att{BASEEXT}.bs: $!";
	print STDOUT "Writing $att{BASEEXT}.bs\n";
	print STDOUT "	containing: @all" if $Verbose;
	print BS "# $att{BASEEXT} DynaLoader bootstrap file for $Config{'osname'} architecture.\n";
	print BS "# Do not edit this file, changes will be lost.\n";
	print BS "# This file was automatically generated by the\n";
	print BS "# mkbootstrap routine in ExtUtils/MakeMaker.pm.\n";
	print BS "\@DynaLoader::dl_resolve_using = ";
	if (" @all" =~ m/ -[lL]/){
	    print BS "  dl_findfile(qw(\n  @all\n  ));\n";
	}else{
	    print BS "  qw(@all);\n";
	}
	# write extra code if *_BS says so
	print BS $DynaLoader::bscode if $DynaLoader::bscode;
	print BS "1;\n";
	close BS;
    }

    # special handling for systems which needs a list of all global
    # symbols exported by a modules to be dynamically linked.
    if ($Config{'dlsrc'} =~ /^dl_aix/){
       open EXP, ">$att{BASEEXT}.exp";
       print EXP "#!\nboot_$att{BASEEXT}\n";
       close EXP;
    }
}

# the following keeps AutoSplit happy
package ExtUtils::MakeMaker;
1;

__END__




